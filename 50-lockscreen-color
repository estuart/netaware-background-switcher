# GNOME lock/background by active connection (RHEL 8/9).
# Auto-detects the active local GNOME user; uses picture-URI swatches.
# NET1 -> net1.png (#0e6625), NET2 -> net2.png (#b20021)

PATH=/usr/sbin:/usr/bin:/sbin:/bin

IFACE="$1"
STATUS="$2"

# ---- CONFIG ----
IMG_NET1="file:///usr/local/share/wallpapers/net1.png"
IMG_NET2="file:///usr/local/share/wallpapers/net2.png"
IMG_FALLBACK="$IMG_NET1"
TRIGGER_STATUSES="up vpn-up down vpn-down"   # ignore noisy events

TAG="nm-lockscreen-color"
LOCKFILE="/run/nm-lockscreen-color.lock"
STATEFILE="/run/nm-lockscreen-color.last"

log() { /usr/bin/logger -t "$TAG" "$*"; }
in_list() { for i in $2; do [ "$i" = "$1" ] && return 0; done; return 1; }

# Serialize to avoid concurrent runs fighting each other
exec 9>"$LOCKFILE" || exit 0
flock -n 9 || exit 0

# Only handle decisive events
in_list "$STATUS" "$TRIGGER_STATUSES" || exit 0

# Debounce a touch so routes/connections settle
sleep 1

# --- Detect the active local GNOME (Wayland/X11) user ---
detect_gui_user() {
  local CAND=""
  # Columns: SESSION  UID  USER  SEAT  TTY
  while read -r SID UID USER SEAT _; do
    [ -z "$SID" ] && continue
    local TYPE ACTIVE REMOTE
    TYPE=$(/usr/bin/loginctl show-session "$SID" -p Type --value 2>/dev/null)
    ACTIVE=$(/usr/bin/loginctl show-session "$SID" -p Active --value 2>/dev/null)
    REMOTE=$(/usr/bin/loginctl show-session "$SID" -p Remote --value 2>/dev/null)
    # Want: active, local, graphical
    if [ "$ACTIVE" = "yes" ] && [ "$REMOTE" = "no" ] && { [ "$TYPE" = "wayland" ] || [ "$TYPE" = "x11" ]; }; then
      # Require gnome-shell for that user
      if /usr/bin/pgrep -u "$USER" -x gnome-shell >/dev/null 2>&1; then
        [ "$SEAT" = "seat0" ] && { echo "$USER"; return 0; }
        [ -z "$CAND" ] && CAND="$USER"
      fi
    fi
  done < <(/usr/bin/loginctl list-sessions --no-legend 2>/dev/null)

  # Fallback 1: first user with gnome-shell
  if [ -z "$CAND" ]; then
    CAND=$(/usr/bin/ps -C gnome-shell -o user= --sort=etimes 2>/dev/null | head -n1)
  fi
  # Fallback 2: any user with a user-bus
  if [ -z "$CAND" ]; then
    for d in /run/user/*; do
      [ -S "$d/bus" ] || continue
      local uid user
      uid=$(basename "$d")
      user=$(/usr/bin/id -nu "$uid" 2>/dev/null || true)
      [ -n "$user" ] && { CAND="$user"; break; }
    done
  fi

  [ -n "$CAND" ] && { echo "$CAND"; return 0; }
  return 1
}

# Build user DBus env
setup_user_bus_env() {
  local user="$1" uid
  uid=$(/usr/bin/id -u "$user" 2>/dev/null) || return 1
  export XDG_RUNTIME_DIR="/run/user/${uid}"
  export DBUS_SESSION_BUS_ADDRESS="unix:path=${XDG_RUNTIME_DIR}/bus"
  [ -S "${XDG_RUNTIME_DIR}/bus" ] || return 2
  return 0
}

apply_image() {
  local user="$1" img="$2"
  /usr/sbin/runuser -u "$user" -- /usr/bin/gsettings set org.gnome.desktop.screensaver picture-options 'scaled'
  /usr/sbin/runuser -u "$user" -- /usr/bin/gsettings set org.gnome.desktop.screensaver picture-uri "$img"
  /usr/sbin/runuser -u "$user" -- /usr/bin/gsettings set org.gnome.desktop.background picture-options 'scaled'
  /usr/sbin/runuser -u "$user" -- /usr/bin/gsettings set org.gnome.desktop.background picture-uri "$img"
  /usr/sbin/runuser -u "$user" -- /usr/bin/gsettings set org.gnome.desktop.background picture-uri-dark "$img" 2>/dev/null || true
}

# Decide authoritative active connection:
# 1) Prefer an active VPN, else 2) the connection on the default-route device, else 3) first active.
pick_active_connection() {
  local vpn_name def_dev
  vpn_name=$(/usr/bin/nmcli -t -f NAME,TYPE connection show --active | awk -F: '$2=="vpn"{print $1; exit}')
  if [ -n "$vpn_name" ]; then echo "$vpn_name"; return; fi

  def_dev=$(/usr/sbin/ip route show default 2>/dev/null | awk '{print $5; exit}')
  if [ -n "$def_dev" ]; then
    /usr/bin/nmcli -t -f NAME,DEVICE connection show --active | awk -F: -v d="$def_dev" '$2==d{print $1; exit}'
    return
  fi

  /usr/bin/nmcli -t -f NAME connection show --active | head -n1
}

# Map connection name -> image
pick_image_for_conn() {
  case "$1" in
    NET1) echo "$IMG_NET1" ;;
    NET2) echo "$IMG_NET2" ;;
    *)    echo "$IMG_FALLBACK" ;;
  esac
}

# --- Main ---
GUI_USER="$(detect_gui_user)"
if [ -z "$GUI_USER" ]; then
  log "No active local GNOME user detected; skipping."
  exit 0
fi

if ! setup_user_bus_env "$GUI_USER"; then
  log "No session bus for $GUI_USER; skipping."
  exit 0
fi

ACTIVE_CONN="$(pick_active_connection)"
[ -z "$ACTIVE_CONN" ] && ACTIVE_CONN="${CONNECTION_ID:-}"
IMG="$(pick_image_for_conn "$ACTIVE_CONN")"

# Skip if already applied (same user+conn+img)
if [ -f "$STATEFILE" ] && grep -qx "$GUI_USER|$ACTIVE_CONN|$IMG" "$STATEFILE" 2>/dev/null; then
  log "No change (USER=$GUI_USER ACTIVE_CONN=$ACTIVE_CONN)."
  exit 0
fi

log "IFACE=$IFACE STATUS=$STATUS USER=$GUI_USER ACTIVE_CONN=$ACTIVE_CONN -> $IMG"
if apply_image "$GUI_USER" "$IMG"; then
  printf "%s|%s|%s\n" "$GUI_USER" "$ACTIVE_CONN" "$IMG" > "$STATEFILE"
else
  log "ERROR: failed to apply image for $ACTIVE_CONN ($GUI_USER)"
fi

exit 0
